// Code generated by protoc-gen-go.
// source: leverrpc.proto
// DO NOT EDIT!

/*
Package core is a generated protocol buffer package.

It is generated from these files:
	leverrpc.proto

It has these top-level messages:
	RPC
	StreamMessage
	RPCReply
	JSON
	JSONObject
	JSONArray
	JSONProperty
*/
package core

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

// RPC is the message used to invoke a Lever service's method.
type RPC struct {
	// Types that are valid to be assigned to ArgsOneof:
	//	*RPC_Args
	//	*RPC_ByteArgs
	ArgsOneof isRPC_ArgsOneof `protobuf_oneof:"args_oneof"`
}

func (m *RPC) Reset()                    { *m = RPC{} }
func (m *RPC) String() string            { return proto.CompactTextString(m) }
func (*RPC) ProtoMessage()               {}
func (*RPC) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type isRPC_ArgsOneof interface {
	isRPC_ArgsOneof()
}

type RPC_Args struct {
	Args *JSONArray `protobuf:"bytes,1,opt,name=args,oneof"`
}
type RPC_ByteArgs struct {
	ByteArgs []byte `protobuf:"bytes,2,opt,name=byte_args,json=byteArgs,proto3,oneof"`
}

func (*RPC_Args) isRPC_ArgsOneof()     {}
func (*RPC_ByteArgs) isRPC_ArgsOneof() {}

func (m *RPC) GetArgsOneof() isRPC_ArgsOneof {
	if m != nil {
		return m.ArgsOneof
	}
	return nil
}

func (m *RPC) GetArgs() *JSONArray {
	if x, ok := m.GetArgsOneof().(*RPC_Args); ok {
		return x.Args
	}
	return nil
}

func (m *RPC) GetByteArgs() []byte {
	if x, ok := m.GetArgsOneof().(*RPC_ByteArgs); ok {
		return x.ByteArgs
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RPC) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RPC_OneofMarshaler, _RPC_OneofUnmarshaler, _RPC_OneofSizer, []interface{}{
		(*RPC_Args)(nil),
		(*RPC_ByteArgs)(nil),
	}
}

func _RPC_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RPC)
	// args_oneof
	switch x := m.ArgsOneof.(type) {
	case *RPC_Args:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Args); err != nil {
			return err
		}
	case *RPC_ByteArgs:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.ByteArgs)
	case nil:
	default:
		return fmt.Errorf("RPC.ArgsOneof has unexpected type %T", x)
	}
	return nil
}

func _RPC_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RPC)
	switch tag {
	case 1: // args_oneof.args
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(JSONArray)
		err := b.DecodeMessage(msg)
		m.ArgsOneof = &RPC_Args{msg}
		return true, err
	case 2: // args_oneof.byte_args
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.ArgsOneof = &RPC_ByteArgs{x}
		return true, err
	default:
		return false, nil
	}
}

func _RPC_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RPC)
	// args_oneof
	switch x := m.ArgsOneof.(type) {
	case *RPC_Args:
		s := proto.Size(x.Args)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RPC_ByteArgs:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ByteArgs)))
		n += len(x.ByteArgs)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// StreamMessage represents individual messages sent in a streaming RPC call.
// These may be either sent or received.
type StreamMessage struct {
	// Note that the invokation details (rpc field) are part of the very first
	// message sent by the client. It is an error for any other message to have
	// that field set.
	// Also, the very first message sent by the server must be an empty
	// message. This is a workaround for some reverse-proxies which do funny
	// things if there's no data frame.
	//
	// Types that are valid to be assigned to MessageOneof:
	//	*StreamMessage_Rpc
	//	*StreamMessage_Message
	//	*StreamMessage_ByteMessage
	//	*StreamMessage_Error
	//	*StreamMessage_ByteError
	MessageOneof isStreamMessage_MessageOneof `protobuf_oneof:"message_oneof"`
}

func (m *StreamMessage) Reset()                    { *m = StreamMessage{} }
func (m *StreamMessage) String() string            { return proto.CompactTextString(m) }
func (*StreamMessage) ProtoMessage()               {}
func (*StreamMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type isStreamMessage_MessageOneof interface {
	isStreamMessage_MessageOneof()
}

type StreamMessage_Rpc struct {
	Rpc *RPC `protobuf:"bytes,1,opt,name=rpc,oneof"`
}
type StreamMessage_Message struct {
	Message *JSON `protobuf:"bytes,2,opt,name=message,oneof"`
}
type StreamMessage_ByteMessage struct {
	ByteMessage []byte `protobuf:"bytes,3,opt,name=byte_message,json=byteMessage,proto3,oneof"`
}
type StreamMessage_Error struct {
	Error *JSON `protobuf:"bytes,4,opt,name=error,oneof"`
}
type StreamMessage_ByteError struct {
	ByteError []byte `protobuf:"bytes,5,opt,name=byte_error,json=byteError,proto3,oneof"`
}

func (*StreamMessage_Rpc) isStreamMessage_MessageOneof()         {}
func (*StreamMessage_Message) isStreamMessage_MessageOneof()     {}
func (*StreamMessage_ByteMessage) isStreamMessage_MessageOneof() {}
func (*StreamMessage_Error) isStreamMessage_MessageOneof()       {}
func (*StreamMessage_ByteError) isStreamMessage_MessageOneof()   {}

func (m *StreamMessage) GetMessageOneof() isStreamMessage_MessageOneof {
	if m != nil {
		return m.MessageOneof
	}
	return nil
}

func (m *StreamMessage) GetRpc() *RPC {
	if x, ok := m.GetMessageOneof().(*StreamMessage_Rpc); ok {
		return x.Rpc
	}
	return nil
}

func (m *StreamMessage) GetMessage() *JSON {
	if x, ok := m.GetMessageOneof().(*StreamMessage_Message); ok {
		return x.Message
	}
	return nil
}

func (m *StreamMessage) GetByteMessage() []byte {
	if x, ok := m.GetMessageOneof().(*StreamMessage_ByteMessage); ok {
		return x.ByteMessage
	}
	return nil
}

func (m *StreamMessage) GetError() *JSON {
	if x, ok := m.GetMessageOneof().(*StreamMessage_Error); ok {
		return x.Error
	}
	return nil
}

func (m *StreamMessage) GetByteError() []byte {
	if x, ok := m.GetMessageOneof().(*StreamMessage_ByteError); ok {
		return x.ByteError
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*StreamMessage) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _StreamMessage_OneofMarshaler, _StreamMessage_OneofUnmarshaler, _StreamMessage_OneofSizer, []interface{}{
		(*StreamMessage_Rpc)(nil),
		(*StreamMessage_Message)(nil),
		(*StreamMessage_ByteMessage)(nil),
		(*StreamMessage_Error)(nil),
		(*StreamMessage_ByteError)(nil),
	}
}

func _StreamMessage_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*StreamMessage)
	// message_oneof
	switch x := m.MessageOneof.(type) {
	case *StreamMessage_Rpc:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Rpc); err != nil {
			return err
		}
	case *StreamMessage_Message:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Message); err != nil {
			return err
		}
	case *StreamMessage_ByteMessage:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.ByteMessage)
	case *StreamMessage_Error:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case *StreamMessage_ByteError:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.ByteError)
	case nil:
	default:
		return fmt.Errorf("StreamMessage.MessageOneof has unexpected type %T", x)
	}
	return nil
}

func _StreamMessage_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*StreamMessage)
	switch tag {
	case 1: // message_oneof.rpc
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RPC)
		err := b.DecodeMessage(msg)
		m.MessageOneof = &StreamMessage_Rpc{msg}
		return true, err
	case 2: // message_oneof.message
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(JSON)
		err := b.DecodeMessage(msg)
		m.MessageOneof = &StreamMessage_Message{msg}
		return true, err
	case 3: // message_oneof.byte_message
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.MessageOneof = &StreamMessage_ByteMessage{x}
		return true, err
	case 4: // message_oneof.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(JSON)
		err := b.DecodeMessage(msg)
		m.MessageOneof = &StreamMessage_Error{msg}
		return true, err
	case 5: // message_oneof.byte_error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.MessageOneof = &StreamMessage_ByteError{x}
		return true, err
	default:
		return false, nil
	}
}

func _StreamMessage_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*StreamMessage)
	// message_oneof
	switch x := m.MessageOneof.(type) {
	case *StreamMessage_Rpc:
		s := proto.Size(x.Rpc)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *StreamMessage_Message:
		s := proto.Size(x.Message)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *StreamMessage_ByteMessage:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ByteMessage)))
		n += len(x.ByteMessage)
	case *StreamMessage_Error:
		s := proto.Size(x.Error)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *StreamMessage_ByteError:
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ByteError)))
		n += len(x.ByteError)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// RPCReply is used as a return value for a Lever RPC method invokation.
type RPCReply struct {
	// Types that are valid to be assigned to ResultOneof:
	//	*RPCReply_Result
	//	*RPCReply_ByteResult
	//	*RPCReply_Error
	//	*RPCReply_ByteError
	ResultOneof isRPCReply_ResultOneof `protobuf_oneof:"result_oneof"`
}

func (m *RPCReply) Reset()                    { *m = RPCReply{} }
func (m *RPCReply) String() string            { return proto.CompactTextString(m) }
func (*RPCReply) ProtoMessage()               {}
func (*RPCReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type isRPCReply_ResultOneof interface {
	isRPCReply_ResultOneof()
}

type RPCReply_Result struct {
	Result *JSON `protobuf:"bytes,1,opt,name=result,oneof"`
}
type RPCReply_ByteResult struct {
	ByteResult []byte `protobuf:"bytes,2,opt,name=byte_result,json=byteResult,proto3,oneof"`
}
type RPCReply_Error struct {
	Error *JSON `protobuf:"bytes,3,opt,name=error,oneof"`
}
type RPCReply_ByteError struct {
	ByteError []byte `protobuf:"bytes,4,opt,name=byte_error,json=byteError,proto3,oneof"`
}

func (*RPCReply_Result) isRPCReply_ResultOneof()     {}
func (*RPCReply_ByteResult) isRPCReply_ResultOneof() {}
func (*RPCReply_Error) isRPCReply_ResultOneof()      {}
func (*RPCReply_ByteError) isRPCReply_ResultOneof()  {}

func (m *RPCReply) GetResultOneof() isRPCReply_ResultOneof {
	if m != nil {
		return m.ResultOneof
	}
	return nil
}

func (m *RPCReply) GetResult() *JSON {
	if x, ok := m.GetResultOneof().(*RPCReply_Result); ok {
		return x.Result
	}
	return nil
}

func (m *RPCReply) GetByteResult() []byte {
	if x, ok := m.GetResultOneof().(*RPCReply_ByteResult); ok {
		return x.ByteResult
	}
	return nil
}

func (m *RPCReply) GetError() *JSON {
	if x, ok := m.GetResultOneof().(*RPCReply_Error); ok {
		return x.Error
	}
	return nil
}

func (m *RPCReply) GetByteError() []byte {
	if x, ok := m.GetResultOneof().(*RPCReply_ByteError); ok {
		return x.ByteError
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RPCReply) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RPCReply_OneofMarshaler, _RPCReply_OneofUnmarshaler, _RPCReply_OneofSizer, []interface{}{
		(*RPCReply_Result)(nil),
		(*RPCReply_ByteResult)(nil),
		(*RPCReply_Error)(nil),
		(*RPCReply_ByteError)(nil),
	}
}

func _RPCReply_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RPCReply)
	// result_oneof
	switch x := m.ResultOneof.(type) {
	case *RPCReply_Result:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Result); err != nil {
			return err
		}
	case *RPCReply_ByteResult:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.ByteResult)
	case *RPCReply_Error:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Error); err != nil {
			return err
		}
	case *RPCReply_ByteError:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		b.EncodeRawBytes(x.ByteError)
	case nil:
	default:
		return fmt.Errorf("RPCReply.ResultOneof has unexpected type %T", x)
	}
	return nil
}

func _RPCReply_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RPCReply)
	switch tag {
	case 1: // result_oneof.result
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(JSON)
		err := b.DecodeMessage(msg)
		m.ResultOneof = &RPCReply_Result{msg}
		return true, err
	case 2: // result_oneof.byte_result
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.ResultOneof = &RPCReply_ByteResult{x}
		return true, err
	case 3: // result_oneof.error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(JSON)
		err := b.DecodeMessage(msg)
		m.ResultOneof = &RPCReply_Error{msg}
		return true, err
	case 4: // result_oneof.byte_error
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeRawBytes(true)
		m.ResultOneof = &RPCReply_ByteError{x}
		return true, err
	default:
		return false, nil
	}
}

func _RPCReply_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RPCReply)
	// result_oneof
	switch x := m.ResultOneof.(type) {
	case *RPCReply_Result:
		s := proto.Size(x.Result)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RPCReply_ByteResult:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ByteResult)))
		n += len(x.ByteResult)
	case *RPCReply_Error:
		s := proto.Size(x.Error)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RPCReply_ByteError:
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.ByteError)))
		n += len(x.ByteError)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// JSON represents a JSON-like value, which is represented as a proto message.
type JSON struct {
	// Note: If none are set then the value is null.
	//
	// Types that are valid to be assigned to JsonValueOneof:
	//	*JSON_JsonString
	//	*JSON_JsonNumber
	//	*JSON_JsonBool
	//	*JSON_JsonObject
	//	*JSON_JsonArray
	JsonValueOneof isJSON_JsonValueOneof `protobuf_oneof:"json_value_oneof"`
}

func (m *JSON) Reset()                    { *m = JSON{} }
func (m *JSON) String() string            { return proto.CompactTextString(m) }
func (*JSON) ProtoMessage()               {}
func (*JSON) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type isJSON_JsonValueOneof interface {
	isJSON_JsonValueOneof()
}

type JSON_JsonString struct {
	JsonString string `protobuf:"bytes,1,opt,name=json_string,json=jsonString,oneof"`
}
type JSON_JsonNumber struct {
	JsonNumber float64 `protobuf:"fixed64,2,opt,name=json_number,json=jsonNumber,oneof"`
}
type JSON_JsonBool struct {
	JsonBool bool `protobuf:"varint,3,opt,name=json_bool,json=jsonBool,oneof"`
}
type JSON_JsonObject struct {
	JsonObject *JSONObject `protobuf:"bytes,4,opt,name=json_object,json=jsonObject,oneof"`
}
type JSON_JsonArray struct {
	JsonArray *JSONArray `protobuf:"bytes,5,opt,name=json_array,json=jsonArray,oneof"`
}

func (*JSON_JsonString) isJSON_JsonValueOneof() {}
func (*JSON_JsonNumber) isJSON_JsonValueOneof() {}
func (*JSON_JsonBool) isJSON_JsonValueOneof()   {}
func (*JSON_JsonObject) isJSON_JsonValueOneof() {}
func (*JSON_JsonArray) isJSON_JsonValueOneof()  {}

func (m *JSON) GetJsonValueOneof() isJSON_JsonValueOneof {
	if m != nil {
		return m.JsonValueOneof
	}
	return nil
}

func (m *JSON) GetJsonString() string {
	if x, ok := m.GetJsonValueOneof().(*JSON_JsonString); ok {
		return x.JsonString
	}
	return ""
}

func (m *JSON) GetJsonNumber() float64 {
	if x, ok := m.GetJsonValueOneof().(*JSON_JsonNumber); ok {
		return x.JsonNumber
	}
	return 0
}

func (m *JSON) GetJsonBool() bool {
	if x, ok := m.GetJsonValueOneof().(*JSON_JsonBool); ok {
		return x.JsonBool
	}
	return false
}

func (m *JSON) GetJsonObject() *JSONObject {
	if x, ok := m.GetJsonValueOneof().(*JSON_JsonObject); ok {
		return x.JsonObject
	}
	return nil
}

func (m *JSON) GetJsonArray() *JSONArray {
	if x, ok := m.GetJsonValueOneof().(*JSON_JsonArray); ok {
		return x.JsonArray
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*JSON) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _JSON_OneofMarshaler, _JSON_OneofUnmarshaler, _JSON_OneofSizer, []interface{}{
		(*JSON_JsonString)(nil),
		(*JSON_JsonNumber)(nil),
		(*JSON_JsonBool)(nil),
		(*JSON_JsonObject)(nil),
		(*JSON_JsonArray)(nil),
	}
}

func _JSON_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*JSON)
	// json_value_oneof
	switch x := m.JsonValueOneof.(type) {
	case *JSON_JsonString:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.JsonString)
	case *JSON_JsonNumber:
		b.EncodeVarint(2<<3 | proto.WireFixed64)
		b.EncodeFixed64(math.Float64bits(x.JsonNumber))
	case *JSON_JsonBool:
		t := uint64(0)
		if x.JsonBool {
			t = 1
		}
		b.EncodeVarint(3<<3 | proto.WireVarint)
		b.EncodeVarint(t)
	case *JSON_JsonObject:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.JsonObject); err != nil {
			return err
		}
	case *JSON_JsonArray:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.JsonArray); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("JSON.JsonValueOneof has unexpected type %T", x)
	}
	return nil
}

func _JSON_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*JSON)
	switch tag {
	case 1: // json_value_oneof.json_string
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.JsonValueOneof = &JSON_JsonString{x}
		return true, err
	case 2: // json_value_oneof.json_number
		if wire != proto.WireFixed64 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.JsonValueOneof = &JSON_JsonNumber{math.Float64frombits(x)}
		return true, err
	case 3: // json_value_oneof.json_bool
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.JsonValueOneof = &JSON_JsonBool{x != 0}
		return true, err
	case 4: // json_value_oneof.json_object
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(JSONObject)
		err := b.DecodeMessage(msg)
		m.JsonValueOneof = &JSON_JsonObject{msg}
		return true, err
	case 5: // json_value_oneof.json_array
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(JSONArray)
		err := b.DecodeMessage(msg)
		m.JsonValueOneof = &JSON_JsonArray{msg}
		return true, err
	default:
		return false, nil
	}
}

func _JSON_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*JSON)
	// json_value_oneof
	switch x := m.JsonValueOneof.(type) {
	case *JSON_JsonString:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.JsonString)))
		n += len(x.JsonString)
	case *JSON_JsonNumber:
		n += proto.SizeVarint(2<<3 | proto.WireFixed64)
		n += 8
	case *JSON_JsonBool:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case *JSON_JsonObject:
		s := proto.Size(x.JsonObject)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *JSON_JsonArray:
		s := proto.Size(x.JsonArray)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type JSONObject struct {
	Property []*JSONProperty `protobuf:"bytes,1,rep,name=property" json:"property,omitempty"`
}

func (m *JSONObject) Reset()                    { *m = JSONObject{} }
func (m *JSONObject) String() string            { return proto.CompactTextString(m) }
func (*JSONObject) ProtoMessage()               {}
func (*JSONObject) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *JSONObject) GetProperty() []*JSONProperty {
	if m != nil {
		return m.Property
	}
	return nil
}

type JSONArray struct {
	Element []*JSON `protobuf:"bytes,1,rep,name=element" json:"element,omitempty"`
}

func (m *JSONArray) Reset()                    { *m = JSONArray{} }
func (m *JSONArray) String() string            { return proto.CompactTextString(m) }
func (*JSONArray) ProtoMessage()               {}
func (*JSONArray) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *JSONArray) GetElement() []*JSON {
	if m != nil {
		return m.Element
	}
	return nil
}

type JSONProperty struct {
	Name  string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Value *JSON  `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *JSONProperty) Reset()                    { *m = JSONProperty{} }
func (m *JSONProperty) String() string            { return proto.CompactTextString(m) }
func (*JSONProperty) ProtoMessage()               {}
func (*JSONProperty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *JSONProperty) GetValue() *JSON {
	if m != nil {
		return m.Value
	}
	return nil
}

func init() {
	proto.RegisterType((*RPC)(nil), "core.RPC")
	proto.RegisterType((*StreamMessage)(nil), "core.StreamMessage")
	proto.RegisterType((*RPCReply)(nil), "core.RPCReply")
	proto.RegisterType((*JSON)(nil), "core.JSON")
	proto.RegisterType((*JSONObject)(nil), "core.JSONObject")
	proto.RegisterType((*JSONArray)(nil), "core.JSONArray")
	proto.RegisterType((*JSONProperty)(nil), "core.JSONProperty")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion2

// Client API for LeverRPC service

type LeverRPCClient interface {
	HandleRPC(ctx context.Context, in *RPC, opts ...grpc.CallOption) (*RPCReply, error)
	HandleStreamingRPC(ctx context.Context, opts ...grpc.CallOption) (LeverRPC_HandleStreamingRPCClient, error)
}

type leverRPCClient struct {
	cc *grpc.ClientConn
}

func NewLeverRPCClient(cc *grpc.ClientConn) LeverRPCClient {
	return &leverRPCClient{cc}
}

func (c *leverRPCClient) HandleRPC(ctx context.Context, in *RPC, opts ...grpc.CallOption) (*RPCReply, error) {
	out := new(RPCReply)
	err := grpc.Invoke(ctx, "/core.LeverRPC/HandleRPC", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *leverRPCClient) HandleStreamingRPC(ctx context.Context, opts ...grpc.CallOption) (LeverRPC_HandleStreamingRPCClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_LeverRPC_serviceDesc.Streams[0], c.cc, "/core.LeverRPC/HandleStreamingRPC", opts...)
	if err != nil {
		return nil, err
	}
	x := &leverRPCHandleStreamingRPCClient{stream}
	return x, nil
}

type LeverRPC_HandleStreamingRPCClient interface {
	Send(*StreamMessage) error
	Recv() (*StreamMessage, error)
	grpc.ClientStream
}

type leverRPCHandleStreamingRPCClient struct {
	grpc.ClientStream
}

func (x *leverRPCHandleStreamingRPCClient) Send(m *StreamMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *leverRPCHandleStreamingRPCClient) Recv() (*StreamMessage, error) {
	m := new(StreamMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for LeverRPC service

type LeverRPCServer interface {
	HandleRPC(context.Context, *RPC) (*RPCReply, error)
	HandleStreamingRPC(LeverRPC_HandleStreamingRPCServer) error
}

func RegisterLeverRPCServer(s *grpc.Server, srv LeverRPCServer) {
	s.RegisterService(&_LeverRPC_serviceDesc, srv)
}

func _LeverRPC_HandleRPC_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RPC)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LeverRPCServer).HandleRPC(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/core.LeverRPC/HandleRPC",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LeverRPCServer).HandleRPC(ctx, req.(*RPC))
	}
	return interceptor(ctx, in, info, handler)
}

func _LeverRPC_HandleStreamingRPC_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(LeverRPCServer).HandleStreamingRPC(&leverRPCHandleStreamingRPCServer{stream})
}

type LeverRPC_HandleStreamingRPCServer interface {
	Send(*StreamMessage) error
	Recv() (*StreamMessage, error)
	grpc.ServerStream
}

type leverRPCHandleStreamingRPCServer struct {
	grpc.ServerStream
}

func (x *leverRPCHandleStreamingRPCServer) Send(m *StreamMessage) error {
	return x.ServerStream.SendMsg(m)
}

func (x *leverRPCHandleStreamingRPCServer) Recv() (*StreamMessage, error) {
	m := new(StreamMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _LeverRPC_serviceDesc = grpc.ServiceDesc{
	ServiceName: "core.LeverRPC",
	HandlerType: (*LeverRPCServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HandleRPC",
			Handler:    _LeverRPC_HandleRPC_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "HandleStreamingRPC",
			Handler:       _LeverRPC_HandleStreamingRPC_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
}

var fileDescriptor0 = []byte{
	// 522 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x8c, 0x54, 0x4d, 0x6f, 0xd3, 0x40,
	0x10, 0x8d, 0x89, 0xd3, 0xc6, 0x13, 0x37, 0xad, 0x96, 0x4b, 0x55, 0x09, 0x51, 0xcc, 0x87, 0x72,
	0xb2, 0x4a, 0x7a, 0xe5, 0xd2, 0x50, 0xa4, 0x0a, 0x41, 0x5b, 0x39, 0x27, 0x4e, 0x91, 0x1d, 0x86,
	0x88, 0xca, 0xf6, 0x46, 0x6b, 0xa7, 0x52, 0xf8, 0x45, 0xfc, 0x1d, 0xfe, 0x04, 0xbf, 0x83, 0x99,
	0xd9, 0xb5, 0xdd, 0xaa, 0x39, 0x70, 0xf3, 0xbe, 0x79, 0xfb, 0xde, 0xdb, 0x9d, 0x59, 0xc3, 0x38,
	0xc7, 0x7b, 0x34, 0x66, 0xbd, 0x8c, 0xd7, 0x46, 0xd7, 0x5a, 0xf9, 0x4b, 0x6d, 0x30, 0xfa, 0x06,
	0xfd, 0xe4, 0xf6, 0xa3, 0x7a, 0x0b, 0x7e, 0x6a, 0x56, 0xd5, 0xb1, 0x77, 0xea, 0x4d, 0x46, 0xd3,
	0xc3, 0x98, 0x6b, 0xf1, 0xe7, 0xf9, 0xcd, 0xf5, 0x85, 0x31, 0xe9, 0xf6, 0xaa, 0x97, 0x48, 0x59,
	0xbd, 0x80, 0x20, 0xdb, 0xd6, 0xb8, 0x10, 0xee, 0x33, 0xe2, 0x86, 0x54, 0x1a, 0x32, 0x74, 0x41,
	0xc8, 0x2c, 0x04, 0xe0, 0xca, 0x42, 0x97, 0xa8, 0x7f, 0x44, 0x7f, 0x3c, 0x38, 0x98, 0xd7, 0x06,
	0xd3, 0xe2, 0x2b, 0x56, 0x55, 0xba, 0x42, 0xda, 0xde, 0x27, 0x7f, 0x67, 0x12, 0x58, 0x13, 0x72,
	0x27, 0x0d, 0xc6, 0xd5, 0x3b, 0xd8, 0x2f, 0x2c, 0x53, 0xb4, 0x47, 0x53, 0xe8, 0x72, 0x10, 0xa7,
	0x29, 0xaa, 0xd7, 0x10, 0x4a, 0x8a, 0x86, 0xdc, 0x77, 0x41, 0x46, 0x8c, 0x36, 0x5e, 0x11, 0x0c,
	0xe8, 0xb4, 0xda, 0x1c, 0xfb, 0x3b, 0xa4, 0x6c, 0x49, 0xbd, 0x04, 0x10, 0x21, 0x4b, 0x1c, 0x38,
	0x19, 0x39, 0xe2, 0x27, 0x86, 0x66, 0x87, 0x70, 0xe0, 0x4c, 0xdc, 0x99, 0x7e, 0x7b, 0x30, 0xa4,
	0xc4, 0x09, 0xae, 0xf3, 0xad, 0x7a, 0x03, 0x7b, 0x06, 0xab, 0x4d, 0x5e, 0xbb, 0x13, 0x3d, 0xf6,
	0x70, 0x35, 0xf5, 0x0a, 0x24, 0xd7, 0xc2, 0x51, 0x9b, 0x5b, 0x13, 0xe7, 0xc4, 0x52, 0xda, 0xac,
	0xfd, 0xff, 0xcd, 0xea, 0x3f, 0xcd, 0x3a, 0x86, 0xd0, 0x5a, 0xb8, 0xa8, 0x7f, 0x3d, 0xf0, 0x59,
	0x82, 0x03, 0xdc, 0x55, 0xba, 0x5c, 0x54, 0xb5, 0xf9, 0x59, 0xae, 0x24, 0x6b, 0xc0, 0x01, 0x18,
	0x9c, 0x0b, 0xd6, 0x52, 0xca, 0x4d, 0x91, 0xa1, 0x91, 0x8c, 0x5e, 0x43, 0xb9, 0x16, 0x8c, 0x5b,
	0x2f, 0x94, 0x4c, 0xeb, 0x5c, 0x72, 0x0e, 0xb9, 0xf5, 0x0c, 0xcd, 0x08, 0x51, 0xe7, 0x4e, 0x41,
	0x67, 0x77, 0xb8, 0xac, 0xdd, 0xa5, 0x1f, 0x75, 0x07, 0xb9, 0x11, 0xbc, 0xd1, 0xb4, 0x2b, 0x75,
	0x06, 0xb2, 0xa2, 0x71, 0xa2, 0x21, 0x93, 0xfb, 0xdf, 0x39, 0x7b, 0x62, 0x2c, 0x8b, 0x99, 0x82,
	0x23, 0xd9, 0x71, 0x9f, 0xe6, 0x9b, 0xa6, 0x27, 0x1f, 0x00, 0x3a, 0x07, 0x15, 0xc3, 0x90, 0xe6,
	0x7b, 0x8d, 0xa6, 0xde, 0xd2, 0x51, 0xfb, 0xa4, 0xa8, 0x3a, 0xc5, 0x5b, 0x57, 0x49, 0x5a, 0x4e,
	0xf4, 0x1e, 0x82, 0xd6, 0x8b, 0x3a, 0xba, 0x8f, 0x39, 0x16, 0x58, 0xd6, 0x6e, 0xef, 0x83, 0x56,
	0x24, 0x4d, 0x29, 0xba, 0x84, 0xf0, 0xa1, 0x98, 0x52, 0xe0, 0x97, 0x69, 0x81, 0xf6, 0x66, 0x13,
	0xf9, 0x56, 0xa7, 0x30, 0x90, 0x8c, 0x4f, 0x27, 0x39, 0xb1, 0x85, 0xe9, 0x2f, 0x18, 0x7e, 0xe1,
	0x17, 0xc9, 0xcf, 0x6f, 0x02, 0xc1, 0x55, 0x5a, 0x7e, 0xcf, 0x91, 0x17, 0xdd, 0xc3, 0x38, 0x19,
	0xb7, 0x9f, 0x32, 0x71, 0x51, 0x4f, 0x5d, 0x82, 0xb2, 0x4c, 0xfb, 0xb2, 0xa8, 0x79, 0xbc, 0xe5,
	0xb9, 0xe5, 0x3d, 0x7a, 0x6d, 0x27, 0xbb, 0xc0, 0xa8, 0x37, 0xf1, 0xce, 0x3c, 0xbe, 0xc6, 0xa5,
	0x2e, 0x62, 0xf9, 0x23, 0xe8, 0x4a, 0x78, 0xd9, 0x9e, 0xfc, 0x16, 0xce, 0xff, 0x05, 0x00, 0x00,
	0xff, 0xff, 0x61, 0x13, 0xb1, 0xe0, 0x28, 0x04, 0x00, 0x00,
}
